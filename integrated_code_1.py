# -*- coding: utf-8 -*-
"""Integrated_code_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bblxqpdoqtUTNZNmetAis3pPErkKjOtG
"""

!pip install ultralytics supervision roboflow

import cv2
import numpy as np
import math
from ultralytics import YOLO
from google.colab import files
from collections import defaultdict, deque
from roboflow import Roboflow
import supervision as sv

# Upload video
uploaded = files.upload()
video_path = list(uploaded.keys())[0]
cap = cv2.VideoCapture(video_path)
w, h = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)), int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
fps = cap.get(cv2.CAP_PROP_FPS)
out = cv2.VideoWriter("final_output.mp4", cv2.VideoWriter_fourcc(*'mp4v'), fps, (w, h))

PIXEL_TO_METER = 0.05
MAX_SPEED_KMPH = 50
prev_pos, speed_hist = {}, defaultdict(lambda: deque(maxlen=5))
safety_scores = {}

# Load YOLO model for vehicle speed/count
speed_model = YOLO('yolov8n.pt')

# Roboflow vehicle brand detection
rf1 = Roboflow(api_key="zmpj3OHDepXbqLJdXtTB")  # your working API key
vehicle_model = rf1.workspace("rosh-htrrf").project("vehicle-model-detection-4").version(2).model

# Roboflow pothole detection
rf2 = Roboflow(api_key="QUWMCW70c1dPy9pc03sQ")
pothole_model = rf2.workspace("hiteshram").project("object-detection-bounding-box-ftfs5").version(1).model

brand_weights = {
    "Tata": 10, "Mahindra": 9, "Toyota": 9, "Hyundai": 8,
    "Kia": 7, "Honda": 7, "Maruti": 5, "Suzuki": 5, "Unknown": 5
}

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break

    results = speed_model.track(frame, classes=[2, 3, 5, 7], conf=0.5,
                                persist=True, verbose=False, tracker="botsort.yaml")
    detections = []

    for r in results:
        if not hasattr(r, 'boxes'):
            continue
        for box in r.boxes:
            if box.id is None:
                continue
            tid = int(box.id[0].item())
            x1, y1, x2, y2 = box.xyxy[0].cpu().numpy().astype(int)
            cx, cy = (x1 + x2) // 2, (y1 + y2) // 2
            detections.append((tid, (x1, y1, x2, y2), (cx, cy)))

            if tid in prev_pos:
                dx, dy = cx - prev_pos[tid][0], cy - prev_pos[tid][1]
                dist = math.hypot(dx, dy)
                if dist > 2:
                    speed = dist * PIXEL_TO_METER * fps * 3.6
                    speed_hist[tid].append(speed)
            prev_pos[tid] = (cx, cy)

    # Vehicle Brand Detection
    brand_result = vehicle_model.predict(frame, confidence=40, overlap=30).json()
    brand_map = {}
    for pred in brand_result['predictions']:
        x, y, w, h = int(pred['x']), int(pred['y']), int(pred['width']), int(pred['height'])
        brand = pred['class']
        key = (x - w//2, y - h//2, x + w//2, y + h//2)
        brand_map[key] = brand

    # Pothole Detection
    pothole_result = pothole_model.predict(frame, confidence=40, overlap=30).json()
    pothole_detected = len(pothole_result['predictions']) > 0

    for tid, bbox, center in detections:
        x1, y1, x2, y2 = bbox
        cx, cy = center
        avg_speed = sum(speed_hist[tid]) / len(speed_hist[tid]) if speed_hist[tid] else 0

        # Calculate safety component scores
        speed_score = 35 if avg_speed <= MAX_SPEED_KMPH else 10
        dist_score = 10
        for oid, _, oc in detections:
            if oid != tid and math.hypot(cx - oc[0], cy - oc[1]) < 50:
                dist_score = 0
                break
        pothole_score = 0 if pothole_detected else 20
        traffic_score = 10 if len(detections) < 8 else 5

        brand = "Unknown"
        for (bx1, by1, bx2, by2), bname in brand_map.items():
            if bx1 < cx < bx2 and by1 < cy < by2:
                brand = bname
                break
        model_score = brand_weights.get(brand, 5)

        total = speed_score + dist_score + pothole_score + traffic_score + model_score
        safety_scores[tid] = total

        cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)
        cv2.putText(frame, f"Speed: {avg_speed:.1f}km/h", (x1, y1 - 20),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 0), 2)
        cv2.putText(frame, f"Safety: {total}% | Brand: {brand}", (x1, y2 + 20),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 128, 255), 2)

    cv2.putText(frame, f"Traffic: {len(detections)} vehicles", (20, 30),
                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (200, 200, 200), 2)
    out.write(frame)

cap.release()
out.release()
files.download("final_output.mp4")

!pip install ultralytics supervision roboflow

import cv2
import numpy as np
import math
from ultralytics import YOLO
from google.colab import files
from collections import defaultdict, deque
from roboflow import Roboflow
import supervision as sv

# Upload video
uploaded = files.upload()
video_path = list(uploaded.keys())[0]
cap = cv2.VideoCapture(video_path)
w, h = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)), int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
fps = cap.get(cv2.CAP_PROP_FPS)
out = cv2.VideoWriter("final_output.mp4", cv2.VideoWriter_fourcc(*'mp4v'), fps, (w, h))

# Constants
PIXEL_TO_METER = 0.05
MAX_SPEED_KMPH = 50
prev_pos, speed_hist = {}, defaultdict(lambda: deque(maxlen=5))
safety_scores = {}

# Models
speed_model = YOLO('yolov8n.pt')

# Roboflow Models
rf1 = Roboflow(api_key="zmpj3OHDepXbqLJdXtTB")  # Replace with your actual vehicle model API key
vehicle_model = rf1.workspace("rosh-htrrf").project("vehicle-model-detection-4").version(2).model

rf2 = Roboflow(api_key="QUWMCW70c1dPy9pc03sQ")  # Pothole detection model
pothole_model = rf2.workspace("hiteshram").project("object-detection-bounding-box-ftfs5").version(1).model

brand_weights = {
    "Tata": 10, "Mahindra": 9, "Toyota": 9, "Hyundai": 8,
    "Kia": 7, "Honda": 7, "Maruti": 5, "Suzuki": 5, "Unknown": 5
}

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break

    results = speed_model.track(frame, classes=[2, 3, 5, 7], conf=0.5,
                                persist=True, verbose=False, tracker="botsort.yaml")
    detections = []

    for r in results:
        if not hasattr(r, 'boxes'):
            continue
        for box in r.boxes:
            if box.id is None:
                continue
            tid = int(box.id[0].item())
            x1, y1, x2, y2 = box.xyxy[0].cpu().numpy().astype(int)
            cx, cy = (x1 + x2) // 2, (y1 + y2) // 2
            detections.append((tid, (x1, y1, x2, y2), (cx, cy)))

            if tid in prev_pos:
                dx, dy = cx - prev_pos[tid][0], cy - prev_pos[tid][1]
                dist = math.hypot(dx, dy)
                if dist > 2:
                    speed = dist * PIXEL_TO_METER * fps * 3.6
                    speed_hist[tid].append(speed)
            prev_pos[tid] = (cx, cy)

    # Vehicle Brand Detection
    brand_result = vehicle_model.predict(frame, confidence=40, overlap=30).json()
    brand_map = {}
    for pred in brand_result['predictions']:
        x, y, w, h = int(pred['x']), int(pred['y']), int(pred['width']), int(pred['height'])
        brand = pred['class']
        key = (x - w//2, y - h//2, x + w//2, y + h//2)
        brand_map[key] = brand

    # Pothole Detection Only (Helmet removed)
    pothole_result = pothole_model.predict(frame, confidence=40, overlap=30).json()
    pothole_detected = len(pothole_result['predictions']) > 0

    for tid, bbox, center in detections:
        x1, y1, x2, y2 = bbox
        cx, cy = center
        avg_speed = sum(speed_hist[tid]) / len(speed_hist[tid]) if speed_hist[tid] else 0

        speed_score = 35 if avg_speed <= MAX_SPEED_KMPH else 10
        dist_score = 10
        for oid, _, oc in detections:
            if oid != tid and math.hypot(cx - oc[0], cy - oc[1]) < 50:
                dist_score = 0
                break
        pothole_score = 0 if pothole_detected else 20
        helmet_score = 20  # Assuming always worn now
        traffic_score = 10 if len(detections) < 8 else 5

        brand = "Unknown"
        for (bx1, by1, bx2, by2), bname in brand_map.items():
            if bx1 < cx < bx2 and by1 < cy < by2:
                brand = bname
                break
        model_score = brand_weights.get(brand, 5)

        total = speed_score + dist_score + pothole_score + helmet_score + traffic_score + model_score
        safety_scores[tid] = total

        # Draw bounding box
        cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)

        # --- Draw Speed (Top of box) with shadow ---
        text_speed = f"Speed: {avg_speed:.1f}km/h"
        cv2.putText(frame, text_speed, (x1, y1 - 20),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 0), 5)  # shadow
        cv2.putText(frame, text_speed, (x1, y1 - 20),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 0, 0), 2)  # main

        # --- Draw Safety % + Brand (Below box) with shadow ---
        text_safety = f"Safety: {total}% | Brand: {brand}"
        cv2.putText(frame, text_safety, (x1, y2 + 25),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 0), 5)  # shadow
        cv2.putText(frame, text_safety, (x1, y2 + 25),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 140, 255), 2)  # main (dark orange)

    # Display traffic info
    cv2.putText(frame, f"Traffic: {len(detections)} vehicles", (20, 30),
                cv2.FONT_HERSHEY_SIMPLEX, 0.7, (200, 200, 200), 2)
    out.write(frame)

cap.release()
out.release()
files.download("final_output.mp4")

